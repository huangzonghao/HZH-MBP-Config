export PATH="usr/local/sbin:HOME/local/bin:$PATH"

# always use the vi keymap mode in bash
set -o vi

# depends on different linux distributions
# for common linux distributions the following command is needed for colorful ls
if [[ $SYSTEM_VER = "linux" ]]
then
    alias ls="ls --color=auto"
else
    alias ls="ls -G"
fi

alias la="ls -AG"
alias ll="ls -aoghlGF"
alias cp="cp -i"
alias mv="mv -i"
alias mkdir="mkdir -p"

# set the alias for latexmk -- by huangzonghao@2014.10.4
# note the latexmk is usually installed together with tex distribution
alias laclean="rm  *.out *.dvi *.aux *.fdb_latexmk *.fls *.log *.ps"
alias lmk="latexmk -xelatex -pvc -pdf *.tex"

# note alias doesn't take variables. so it has to be a function
brc(){
    eval source $RC_FILE
}
ebrc(){
    eval vim $RC_FILE
}

alias ebrcc="vim ~/dotfiles/bashrc_common"
alias evrc="vim ~/dotfiles/vimrc"
alias evn="vim ~/dotfiles/vim/docs/updating_notes.txt"
alias e="vim"
alias v="view"
alias vd="vimdiff"
alias n="nano"
alias tree="tree -C"
alias du="du -hsc"
alias cao="./executable"
alias hosts="sudo vim /etc/hosts"

#some funny commands
# sl fortune cowsay cmatrix figlet
# the alias for sublime text --Tue Apr 14 17:23:50 HKT 2015

# recode the gb18030 to utf8
alias g2u="recode gb18030..utf8"

# load all the alias for ssh and sshfs
# first the alias for ssh
declare READ_SSH_TEMP
if [[ -e ~/dotfiles/ssh_list.txt ]]
then
    while read -r line
    do
        if [[ `echo $line | head -c 1` != "#" ]]
        then
            READ_SSH_TEMP=( $line )
            if [[ ${READ_SSH_TEMP[0]} == 0 ]]
            then
                alias ${READ_SSH_TEMP[1]}="ssh ${READ_SSH_TEMP[2]}"
            else
                alias ${READ_SSH_TEMP[1]}="ssh -X ${READ_SSH_TEMP[2]}"
            fi
        fi
    done < ~/dotfiles/ssh_list.txt
fi

# then the alias for sshfs
if [[ -e ~/dotfiles/ssh_mount_list.txt ]]
then
    while read -r line
    do
        if [[ `echo $line | head -c 1` != "#" ]]
        then
            READ_SSH_TEMP=( $line )
            alias ${READ_SSH_TEMP[0]}="sshfs ${READ_SSH_TEMP[1]} ${READ_SSH_TEMP[2]}"
        fi
    done < ~/dotfiles/ssh_mount_list.txt
fi

#############################
######## functions ##########
#############################

# The function to remove the temp files, inspired by the following commands
# remove the .DS_Store file
#alias rmds="find . -name .DS_Store -print0 | xargs -0 git rm -f --ignore-unmatch"
# add {} at the end in case the file name too long error
#alias rmds="find . -name '.DS_Store' -print0 | xargs -0 rm -f {}"

# rm temp files
rmt(){
    declare USER_OPTION;
    declare STATUS=0;
    while [ $STATUS -ne 1 ]
    do
        echo "Which type of temp files would you like to get rid of ?"
        echo ".DS_Store(d) Thumbs.db(t) or Customized (c)?"
        read USER_OPTION

        # make sure you finish processing d and t first because the USER_OPTION is gonna be changed in c and afterwards
        if [[ $USER_OPTION = *d* ]]
        then
            echo "Now start to remove .DS_Store file within this directory"
            find . -name .DS_Store -ls -delete
            echo "Done"
            STATUS=1
        fi
        if [[ $USER_OPTION = *t* ]]
        then
            echo "Now start to remove Thumbs.db file within this directory"
            find . -name Thumbs.db -ls -delete
            echo "Done"
            STATUS=1
        fi
        if [[ $USER_OPTION = *c* ]]
        then
            echo -n "type in the file name : "
            read USER_OPTION
            echo "Now start to remove $USER_OPTION file within this directory"
            find . -name $USER_OPTION -ls -delete
            echo "Done"
            STATUS=1
        fi

        if [[ $STATUS = 1 ]]
        then
            echo -n "Another round? (y/n) : "
            read USER_OPTION
            if [[ $USER_OPTION = "y" ]]
            then STATUS=0
            fi
        fi
    done
    echo "All process done, exit"

}

# a function to package all the templates --Tue Apr  7 13:01:39 HKT 2015
tem(){
    declare STATUS   # use declare to make all the variable local
    declare USER_OPTION
    declare FILE_NAME
    #declare USER
    if [ $# -eq 0 ]
    then
        STATUS=0
    else
        STATUS=1
        OPTION=$1
    fi

    while [ $STATUS -eq 0 ]
    do
        echo "Please enter the type of the template:  1)latex, 2)makefile, 3)sbatch, 4)webpage, 5)website, 6)CMakeLists.txt"
        read  USER_OPTION

        case $USER_OPTION in
            "latex" | "1")
                echo -n "Please enter the file name : "
                read FILE_NAME
                cp -i ~/.vim/template/latex.tex $FILE_NAME.tex; vim $FILE_NAME.tex;
                STATUS=1;
                ;;
            "makefile" | "2")
                cp -i ~/.vim/template/makefile makefile && vim makefile
                STATUS=1;
                ;;
            "sbatch" | "3")
                echo -n "Which version? CPU or GPU : "
                read USER_OPTION
                echo -n "Please enter the file name : "
                read FILE_NAME
                case $USER_OPTION in
                    "cpu" | "CPU")
                        cp -i ~/.vim/template/sbatchcpu.sh $FILE_NAME.sh && vim $FILE_NAME.sh
                        ;;
                    "gpu" | "GPU")
                        cp -i ~/.vim/template/sbatchgpu.sh $FILE_NAME.sh && vim $FILE_NAME.sh
                        ;;
                esac
                STATUS=1;
                ;;
            "webpage" | "4")
                echo -n "Please enter the file name : "
                read FILE_NAME
                cp -r ~/.vim/template/webpage.html ./$FILE_NAME.html && vim $FILE_NAME.html
                STATUS=1;
                ;;
            "website" | "5")
                cp -r ~/.vim/template/website/* .
                STATUS=1;
                ;;
            "cmakelist" | "6")
                echo -n "cuda or opencl or common? (c, cl, com) :"
                read FILE_NAME
                if [[ $FILE_NAME = "c" ]]
                then
                    cp ~/.vim/template/cmake_cuda.txt ./CMakeLists.txt
                    vim CMakeLists.txt
                elif [[ $FILE_NAME = "cl" ]]
                then
                    cp ~/.vim/template/cmake_opencl.txt ./CMakeLists.txt
                    cp -r ~/.vim/template/cmake_opencl_module ./cmake_module
                    vim CMakeLists.txt
                elif [[ $FILE_NAME = "com" ]]
                then
                    cp ~/.vim/template/cmake_common.txt ./CMakeLists.txt
                    vim CMakeLists.txt
                else echo "invalid operation, abort"
                fi
                STATUS=1;
                ;;
        esac
        if [ $STATUS -eq 1 ]
        then
            echo -n "Anther file? (y/n) : ";
            read USER_OPTION;
            if [[ $USER_OPTION = y ]]
            then STATUS=0;
            fi
        fi
    done
}

# the function to kaiguang a cpp source file --Fri May 22 17:51:04 HKT 2015
kaiguang(){
    if [ $# -eq 0 ]
    then
        /bin/cat ~/.vim/template/godbless
    else
        /bin/cat ~/.vim/template/godbless $1 > TEMPFILE
        mv TEMPFILE $1
    fi
}

# the shortcut for making a directory and cd into it
mcd(){
    if [ $# != '0' ]
    then
        mkdir $1;
        cd $1;
    fi
}

checkColor(){
    eval $(echo "no:global default;fi:normal file;di:directory;ln:symbolic link;pi:named pipe;so:socket;do:door;bd:block device;cd:character device;or:orphan symlink;mi:missing file;su:set uid;sg:set gid;tw:sticky other writable;ow:other writable;st:sticky;ex:executable;"|sed -e 's/:/="/g; s/\;/"\n/g')
    IFS=:
    for i in $LS_COLORS
    do
        echo -e "\e[${i#*=}m$( x=${i%=*}; [ "${!x}" ] && echo "${!x}" || echo "$x" )\e[m"
    done
}

trueColor(){
    echo -en "\n   +  "
    for i in {0..35}; do
        printf "%2b " $i
    done
    printf "\n\n %3b  " 0
    for i in {0..15}; do
        echo -en "\033[48;5;${i}m  \033[m "
    done
    #for i in 16 52 88 124 160 196 232; do
    for i in {0..6}; do
        let "i = i*36 +16"
        printf "\n\n %3b  " $i
        for j in {0..35}; do
            let "val = i+j"
            echo -en "\033[48;5;${val}m  \033[m "
        done
    done
    echo -e "\n"
}
asciiColor(){
    T='gYw'   # The test text
    echo "The 'gYw' is the test text"
    echo -e "\n                 40m     41m     42m     43m     44m     45m     46m     47m";
    for FGs in '    m' '   1m' '  30m' '1;30m' '  31m' '1;31m' '  32m' '1;32m' '  33m' '1;33m' '  34m' '1;34m' '  35m' '1;35m' '  36m' '1;36m' '  37m' '1;37m';
    do FG=${FGs// /}
        echo -en " $FGs \033[$FG  $T  "
        for BG in 40m 41m 42m 43m 44m 45m 46m 47m;
        do echo -en "$EINS \033[$FG\033[$BG  $T \033[0m\033[$BG \033[0m";
        done
        echo;
    done
}

# a function to indent c source file with preset styles
beautifyC(){
    declare style=mine
    if [[ $1 == "-l" || $1 == "--linux"  ]]
    then
        style=linux
    elif [[ $i == "-gnu" ]]
    then
        style=gnu
    fi

    for i in $@
    do
        if [[ -e $i ]]
        then
            if [[ $style == "mine" ]]
            then
                indent --no-blank-lines-after-declarations \
                       --blank-lines-after-procedures \
                       --braces-on-if-line -nce \
                       --braces-on-func-def-line \
                       --braces-on-struct-decl-line \
                       --case-indentation2 \
                       --case-brace-indentation0 \
                       $i
            elif [[ $style == "linux" ]]
            then
                indent --linux-style $i
            elif [[ $style == "gnu" ]]
            then
                indent -gnu $i
            fi
        fi
    done
}
alias btfc="beautifyC"
